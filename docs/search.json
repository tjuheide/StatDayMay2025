[
  {
    "objectID": "993_label_spacing.html",
    "href": "993_label_spacing.html",
    "title": "Cheap trick for label spacing",
    "section": "",
    "text": "Spacing around text and labels\nSometimes you might find that a label gets too close to something else.\nBelow are versions of the plot-in-plot survival curves where the exposure group labels are placed differently in the risk table using different values of hjust.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Right-aligned labels (hjust = 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Left-aligned labels (hjust = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Center-aligned labels (hjust = .5)\n\n\n\n\n\n\n\n\nFigure 1 with right aligned labels corresponds to the one you have made already. Here the labels might be a tad too close to the numbers in the risk table. One solution could be to left align the labels as in Figure 2. However, the difference in distance between labels and numbers might be less aesthetically pleasing, and “Intervention” is still close to the text. Figure 3 is just plain ugly. One cheap trick that is often worth remembering is to edit the labels of the data. I.e., if the labels had been specified as here\n\nsurvival &lt;- fread(\"//uni.au.dk/dfs/HE_KEA-DCESAS02/S/Stat day May 2025/risk_curves/data/riskdata.csv\") |&gt;\n  mutate(x = factor(\n    x,\n    levels = c(2,1),\n    # note the space after the labels\n    labels = c(\"Control \", \"Intervention \")\n  )) |&gt;\n  filter(analysis == \"Survival\")\n\nthen there is daylight between the labels and the numbers at risk as seen in Figure 4\n\n\n\n\n\n\nCheap trick\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Right-aligned labels (hjust = 1) with additional space in label\n\n\n\n\n\n\n\nA similar trick can be useful if you need to add space to the left. Suppose you have some time-trend data where there are too many groups to make a good palette, and you decide to remove the legend and instead insert the labels as text to the right of the figures where the individual lines end:\n\nlibrary(ggplot2)\n\n# Some nonsensical data on time trends of something for various animals\n\n# First a table with an observation for each animal in each year\nset.seed(13)\ngrid &lt;- expand.grid(\n  Time = 2020:2025,\n  group = c(\n    \"Cattle\",\n    \"Chickens\",\n    \"Pigs\",\n    \"Turkeys\",\n    \"Horses\",\n    \"Drop bears\",\n    \"Foxes\",\n    \"Guinea pigs\",\n    \"Herrings\"\n  )\n)\n\n# A continuous outcome variable with random values\ngrid$y &lt;- runif(nrow(grid), 0, 10)\n\n# New group variable, constructed by adding some space before the text in the grouping variable\ngrid$new_group &lt;- paste(\" \",grid$group)\n\n# Last observation per group (used to insert the text on the right of the lines)\nanno &lt;- subset(grid, Time == 2025)\n\n# The plot where no space is included between lines and text.\n# Substitute new_group for group to get spacing.\nggplot(grid, aes(x = Time, y = y, color = group)) +\n  theme_classic() +\n  theme(legend.position = \"none\",\n        # expanding margins to the right to make room for the labels\n        plot.margin = margin(t = 0,  \n                             r = 2,  \n                             b = 0,  \n                             l = 0,\n                             unit = \"cm\")) +\n  # setting clip = \"off\" means the text in the margin will not be cut\n  coord_cartesian(clip = \"off\") +\n  geom_line(linewidth = 1.5) +\n  geom_text(data = anno,\n            aes(label = group),\n            hjust = 0)\n\n\n\n\n\n\n\nLabels too close to lines using the variable group\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLabels positioned better using the variable new_group",
    "crumbs": [
      "Notes",
      "Cheap trick for label spacing"
    ]
  },
  {
    "objectID": "991_global_options.html",
    "href": "991_global_options.html",
    "title": "Global options vs global values",
    "section": "",
    "text": "Regarding layout of plots\nIf you are going to make many plots that are too distinct to wrap inside a function, and you therefore need to specify themes and colors in each plot to achieve a coherent style, you may consider specifying your default theme and colors as global options, rather than creating values which you then refer to (possibly many times over) in the individual plot.\n\nlibrary(ggplot2)\nlibrary(dplyr)\n# Setting the default palette for fills and colors to the one proposed by Okabe and Ito for discrete scales\n# (continuous scales can also be specified)\noptions(\n  ggplot2.discrete.fill =  c(\n    \"#E69F00\",\n    \"#56B4E9\",\n    \"#009E73\",\n    \"#F0E442\",\n    \"#0072B2\",\n    \"#D55E00\",\n    \"#CC79A7\",\n    \"#999999\"\n  ),\n  ggplot2.discrete.colour =  c(\n    \"#E69F00\",\n    \"#56B4E9\",\n    \"#009E73\",\n    \"#F0E442\",\n    \"#0072B2\",\n    \"#D55E00\",\n    \"#CC79A7\",\n    \"#999999\"\n  )\n)\n\n# Setting the classic theme as default with a given base size.\n# The legend title will be removed by default and the legend\n# will be inserted inside the plot in the top left corner\ntheme_set(\n  theme_classic(base_size = 15) +\n    theme(legend.title = element_blank(),\n          legend.position = \"inside\",\n          legend.position.inside = c(.1,.8))\n)\n\nmpg |&gt;\n  filter(!(class %in% c(\"subcompact\", \"suv\"))) |&gt;\n  ggplot(aes(class, fill = class, color = class)) +\n  geom_bar(alpha = .7, linewidth = 2)",
    "crumbs": [
      "Notes",
      "Global options vs global values"
    ]
  },
  {
    "objectID": "024_patch.html",
    "href": "024_patch.html",
    "title": "Creating and patching plot components",
    "section": "",
    "text": "Putting it all together\nRun each of your 2 functions on each of the analyses (\"Plague\" and \"Cholera\"). When you apply the function you can make the result into an object in your environment.\n\n\n\n\n\n\nHint\n\n\n\n\n\nFor Plague you can get a plot that you can edit further as such:\n\nPlague_curves &lt;- risk_fun(\"Plague\")\n\n\n\n\n\n\n\n\n\n\nWhy 2 functions\n\n\n\nWe could have included the functionality of atrisk_fun() into risk_fun(), and you might want to do that in real projects (or as you go along here). However, there are a few quirks of patchwork that it might be relevant to look into outside of a function.\n\n\n\nRisk curves and tables combined for each outcome\nAssuming you have created objects Plague_curves, Plague_table, Cholera_curves, and Cholera_table (the names will be used below, but use whichever make sense to you), we can now patch these together. First we will make risk curves with risk tables for one outcome, then for the other, then we will combine everything.\nPut the risk curves on top of the at risk table, as you have done before, for Plague and Cholera separately. Remember to specify the relative heights. Move the y-axis title closer to the plot.\n\n\n\n\n\n\nSolution (Plague)\n\n\n\n\n\n\nPlague &lt;- Plague_curves / Plague_table + \n  plot_layout(heights = c(9,1))\n\nPlague[[1]] &lt;- Plague[[1]] +\n  theme(axis.title.y = element_text(vjust = -10))\n\nDo the same for Cholera - this could have been part of a function.\n\n\n\n\n\nGetting each patchworks to act as one plot - not two plots stitched together\nWe want to annotate our plots by giving each panel an index (letter, number, …) we can refer to. If we blindly put together the 2 patchworks of 2 plots the result will be considered a combination of 4 plots and each will get its own symbol (both plots with curves and risk tables). To prevent that we can use the function wrap_elements() on each of our 2 patchworks.\n\n\n\n\n\n\nHint (Plague)\n\n\n\n\n\nPlague consists of 2 elements each of depth 1, i.e., you don’t need to get to the first element of the first element as you did previously. Here you just need to modify the first element of Plague.\n\n\n\n\n\n\n\n\n\nSolution (Plague)\n\n\n\n\n\n\nPlague &lt;- wrap_elements(Plague)\n\nDo the same for Cholera - this could also have been part of a function.\n\n\n\n\n\nPatching the two outcome figures and adding annotation\nWe are now ready to patch the resulting plots, that now each behave as if they were just one plot.\nThis can be done by the code Plague + Cholera or Plague | Cholera, there should not be a difference in this exercise.\nHowever, when we add annotation it is important to have the code combining the plots in parentheses, e.g., (Plague + Cholera), so be sure to do that.\nWe can add annotation using the function plot_annotation() which has a parameter called tag_level that takes values \"A\", \"a\", \"1\", \"I\" and\"i\" to determine which index you want to use. (You can also specify prefix and suffix if you want an index like Fig 1:.)\nPut together the 2 plots, and add annotation.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n(Plague | Cholera) +\n  plot_annotation(tag_level = \"A\")\n\n\n\n\n\n\nFinishing touches: positioning the tags\nThe tags are perhaps a bit far from the plots (the annotation for the second panel is perhaps too close to the first panel). We can move the tags by adding a custom theme to the above plot. Note that here we need to use & instead of + when we add this custom theme to get it to work on both panels\nIn the custom theme you can specify plot.tag.position in a similar way as we have moved a legend by legend.position.inside. Do that.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n(Plague | Cholera) +\n  plot_annotation(tag_level = \"A\") &\n  theme(plot.tag.position = c(.1, 1))\n\n\n\n\n\n\n\n\n\n\nThe finished plot\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAre the labels a bit close to the numbers in the at risk table? Check out the cheap trick which was applied when making this version of the figure.",
    "crumbs": [
      "Plots in panels",
      "Creating and patching plot components"
    ]
  },
  {
    "objectID": "022_risk_curve_function.html",
    "href": "022_risk_curve_function.html",
    "title": "A function for making risk curves",
    "section": "",
    "text": "Avoid repetitions - use functions\nIn SAS we have macros, R lets us use functions. Here we aim to develop a function which will let us make a risk plot for a specified value of analysis in our risk data set.\nThe first step is to develop one of the plots, then we wrap a function around the code (as you might also do when developing macros), finally we call the function for each value of analysis.\n\nSubsetting to one analysis\nUse filter() to make a data set called temp including only results from risk where analysis takes the value \"Cholera\". Do this by first defining a global value thisanalysis as \"Cholera\", then use thisanalysis rather than \"Cholera\" when filtering.\n\n\n\n\n\n\nHint\n\n\n\n\n\nSpecify thisanalysis\n\nthisanalysis &lt;- \"Cholera\"\n\nThen apply filter() where you restrict to analysis equaling thisanalysis\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nthisanalysis &lt;- \"Cholera\"\ntemp &lt;- risk |&gt;\n  filter(analysis == thisanalysis)\n\n\n\n\n\n\nPlotting the risk curves\nNow make a plot of risk against time with one curve for each exposure group. Follow the same procedure as you did when you made base. You can specify a template theme as well, e.g. theme_classic().\n\n\n\n\n\n\nHint\n\n\n\n\n\nYou need to use the data set temp.\nUse geom_stepribbon(), geom_step(), scale_*_manual(), scale_y_continuous() and theme_*() with parameter spefications as you did previously.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(temp, aes(x = time, y = estimate, color = x, fill = x, ymin = lcl, ymax = ucl)) +\n  geom_stepribbon(show.legend = FALSE,\n                  alpha = .2,\n                  aes(color = NULL)) +\n  geom_step(linewidth = 2) +\n  scale_color_manual(values = mypal) +\n  scale_fill_manual(values = mypal) +\n  scale_y_continuous(labels = percent_format(accuracy = 1)) +\n  theme_classic(base_size = bsize)\n\n\n\n\n\n\n\n\n\n\nRisk of Cholera\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nControlling the legend\nWe want the legend within the plot in this exercise (rather than removed as in the previous). To move the legend into the plot, add a custom theme and set legend.position to \"inside\". Furthermore, specify legend.position.inside within the theme. Let legend.position.inside be a numeric 2-dimensional vector with values between 0 and 1. Finally, remove the legend title by setting legend.title to element_blank() (this is also done inside your custom theme).\n\n\n\n\n\n\nHint\n\n\n\n\n\nYou need to specify the legend position the same way as you did when you made the plots inner and outer from base. Then add the extra parameter legend.position.inside and give it a 2-dimensional value using the function c().\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(temp, aes(x = time, y = estimate, color = x, fill = x, ymin = lcl, ymax = ucl)) +\n  geom_stepribbon(show.legend = FALSE,\n                  alpha = .2,\n                  aes(color = NULL)) +\n  geom_step(linewidth = 2) +\n  scale_color_manual(values = mypal) +\n  scale_fill_manual(values = mypal) +\n  scale_y_continuous(labels = percent_format(accuracy = 1)) +\n  theme_classic(base_size = bsize) +\n  theme(legend.position = \"inside\",\n        legend.position.inside = c(.8, .2),\n        legend.title = element_blank())\n\n\n\n\n\n\nAxis titles\nSpecify that the title on the x-axis should be \"Time\". For the y-axis we want to use the value of thisanalysis so it reads “Risk of [analysis]”. We will use labs() to set the titles. For the x-axis it is simple. For the y-axis we can use the function paste() which allows us to paste different strings together. In labs() set y to paste(\"Risk of\", thisanalysis).\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(temp, aes(x = time, y = estimate, color = x, fill = x, ymin = lcl, ymax = ucl)) +\n  geom_stepribbon(show.legend = FALSE,\n                  alpha = .2,\n                  aes(color = NULL)) +\n  geom_step(linewidth = 2) +\n  scale_color_manual(values = mypal) +\n  scale_fill_manual(values = mypal) +\n  scale_y_continuous(labels = percent_format(accuracy = 1)) +\n  theme_classic(base_size = bsize) +\n  theme(legend.position = \"inside\",\n        legend.position.inside = c(.8, .2),\n        legend.title = element_blank()) +\n  labs(x = \"Time\", y = paste(\"Risk of\", thisanalysis))\n\n\n\n\n\n\nWrapping up the function\nThe contents of the function are essentially ready now. Wrap it up in a function which you can call risk_fun. The function should take the parameter thisanalysis.\n\n\n\n\n\n\nHint (create a function)\n\n\n\n\n\nTo create and name a function you can use the following code\n\nrisk_fun &lt;- function(thisanalysis) {\n  \n}\n\nPut the code that the function needs to execute inside the curly brackets.\n\n\n\n\n\n\n\n\n\nHint (what to put into the function)\n\n\n\n\n\nThe function should first filter the data set then make the plot. Make sure you do not overwrite thisanalysis inside the function.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nTo create and name a function you can use the following code\n\nrisk_fun &lt;- function(thisanalysis) {\n  temp &lt;- risk |&gt;\n    filter(analysis == thisanalysis)\n  \n  ggplot(temp, aes(x = time,\n                   y = estimate,\n                   color = x,\n                   fill = x,\n                   ymin = lcl,\n                   ymax = ucl)) +\n    geom_stepribbon(show.legend = FALSE,\n                    alpha = .2,\n                    aes(color = NULL)) +\n    geom_step(linewidth = 2) +\n    scale_color_manual(values = mypal) +\n    scale_fill_manual(values = mypal) +\n    scale_y_continuous(labels = percent_format(accuracy = 1)) +\n    theme_classic(base_size = bsize) +\n    theme(\n      legend.position = \"inside\",\n      legend.position.inside = c(.8, .2),\n      legend.title = element_blank()\n    ) +\n    labs(x = \"Time\", y = paste(\"Risk of\", thisanalysis))\n}\n\n\n\n\n\n\nApplying the function - unifying scale on y-axes\nApply the function on the two different analyses (risk_fun(\"Cholera\") and risk_fun(\"Plague\")). Notice that the y-axes have different scales. Use coord_cartesian() inside the function to make the y-axis go to 15% (0.15).\n\n\n\n\n\n\nHint\n\n\n\n\n\nIn coord_cartesian() you need to specify ylim which should be given a 2-dimensional vector as input.\n\n\n\n\n\n\n\n\n\nsolution\n\n\n\n\n\n\nrisk_fun &lt;- function(thisanalysis) {\n  temp &lt;- risk |&gt;\n    filter(analysis == thisanalysis)\n  \n  ggplot(temp, aes(x = time,\n                   y = estimate,\n                   color = x,\n                   fill = x,\n                   ymin = lcl,\n                   ymax = ucl)) +\n    geom_stepribbon(show.legend = FALSE,\n                    alpha = .2,\n                    aes(color = NULL)) +\n    geom_step(linewidth = 2) +\n    scale_color_manual(values = mypal) +\n    scale_fill_manual(values = mypal) +\n    scale_y_continuous(labels = percent_format(accuracy = 1)) +\n    theme_classic(base_size = bsize) +\n    theme(\n      legend.position = \"inside\",\n      legend.position.inside = c(.8, .2),\n      legend.title = element_blank()\n    ) +\n    labs(x = \"Time\", y = paste(\"Risk of\", thisanalysis)) +\n    coord_cartesian(ylim = c(0,.15))\n}\n\n\n\n\nThe function should now be ready for use.\n\n\n\n\n\n\nApplying the function on \"Cholera\"\n\n\n\n\n\n\nrisk_fun(\"Cholera\")",
    "crumbs": [
      "Plots in panels",
      "A function for making risk curves"
    ]
  },
  {
    "objectID": "014_risk_table.html",
    "href": "014_risk_table.html",
    "title": "Risk table",
    "section": "",
    "text": "Constructing a table with numbers at risk\nNow we make our risk table. This part does not depend on the previous plots, base, inner, outer or pip.\nFirst, we restrict to observations from our data where there is a number at risk, and for clarity we include only relevant variables.\n\n# the relevant data\natrisk_survival &lt;- survival |&gt;\n  filter(is.na(natrisk) == F) |&gt;\n  select(x, time, natrisk)\n\n\nPlotting numbers in a coordinate system\nThe very basic part of the plot consists of numbers written in a coordinate system. You need to start a new ggplot using the data atrisk_survival. The necessary aesthetics are x, y, and label. The geom_ you need for the risk table is called geom_text(). Make the plot.\n\n\n\n\n\n\nHint\n\n\n\n\n\nThe exposure variable goes into the y-aesthetic.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(atrisk_survival, aes(x = time, y = x, label = natrisk)) +\n  geom_text()\n\n\n\n\n\n\n\n\n\n\nNumbers in a grid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStripping the plot of noise\nWe want to remove almost everything except for the numbers in the risk table. The built-in theme theme_void() removes everything except the data used in the plot. Add theme_void() with base_size specified as you have done for other themes.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(atrisk_survival, aes(x = time, y = x, label = natrisk)) +\n  geom_text() +\n  theme_void(base_size = bsize)\n\n\n\n\n\n\n\n\n\n\nbase_size and text size\n\n\n\nAt this point base_size actually does not affect anything. The size of the text can be modified by the parameter size inside geom_text(). You might want to set size to 4. base_size is not used until we reinsert the labels on the y-axis.\n\n\n\n\nRecreating the y-axis labels\nWe want to get the labels on the y-axes (the levels of the exposure) back into the plot. To do so we add a custom theme, where we set axis.text.y to element_text(hjust = 1, color = mypal). (Try different values for hjust to see what it does.) You will probably get a warning, but it should be safe to ignore in this situation.\n\n\n\n\n\n\nHint\n\n\n\n\n\nAs previously noted, the order of the built-in theme (theme_void()) and your custom theme is important.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(atrisk_survival, aes(x = time, y = x, label = natrisk)) +\n  geom_text(size = 4) +\n  theme_void(base_size = bsize) +\n  theme(axis.text.y = element_text(hjust = 1, color = mypal))\n\n\n\n\n\n\n\n\n\n\nText colors\n\n\n\nIf you want the text in the risk table to take the same colors as the curves, you can add a color aesthetic to your plot. If you do so, make sure to remove the legend as you did in geom_stepribbon().\n\n\n\n\nAdding a title\nNow we add a title to the risk table (so readers will know it shows numbers at risk). This can be done using the function ggtitle(). Simply specify the title you want the risk table to have in ggtitle().\n\n\n\n\n\n\nHint\n\n\n\n\n\nThe title should be included as a string (use quotation marks).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(atrisk_survival, aes(x = time, y = x, label = natrisk)) +\n  geom_text(size = 4) +\n  theme_void(base_size = bsize) +\n  theme(axis.text.y = element_text(hjust = 1, color = mypal)) +\n  ggtitle(\"At risk\")\n\n\n\n\n\n\nEditing the appearance of the title\nThe title might need some adjustment both with regards to position and size. Within your custom theme you can modify the title using the parameter plot.title which can be edited using element_text() (which you also use for axis.text.y). Try setting size to bsize inside element_text() and tinker a bit with hjust until you are happy with its placement. When you are happy with the look of the risk table, make it into an object called risktable.\n\n\n\n\n\n\nAppearance\n\n\n\nAt this stage it can be hard to tell what will look good when combining the risk table and the curves. Consider revising the parameters of the risk table once you have the complete plot.\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nYou can use negative values for hjust if you prefer.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrisktable &lt;- ggplot(atrisk_survival, aes(x = time, y = x, label = natrisk)) +\n  geom_text(size = 4) +\n  theme_void(base_size = bsize) +\n  theme(axis.text.y = element_text(hjust = 1, color = mypal),\n        plot.title = element_text(hjust = -.1, size = bsize)) +\n  ggtitle(\"At risk\")\n\n\n\n\n\n\nThe finished risk table\nYour risk table should now look something like this (with allowance for differences based on personal preferences):\n\n\n\n\n\n\nShow plot",
    "crumbs": [
      "Plot in plot",
      "Risk table"
    ]
  },
  {
    "objectID": "012_risk_plot.html",
    "href": "012_risk_plot.html",
    "title": "The base Kaplan-Meier plot",
    "section": "",
    "text": "Making a base version of the survival curves\nThe first thing we want to do is to make a base version of the survival curves. We will make this an object called base. This base version will then be used in different formats for both the inner and the outer part of the plots.\n\nMaking a stepped curve.\nTo make risk and survival curves we use the function geom_step() from ggplot2.\n\nggplot(survival, aes(x = time, y = estimate)) +\n  geom_step()\n\nAt this point you should should get something rather confused looking - two survival curves mashed up.\n\n\n\n\n\n\nShow plot\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSeparate curves for separate groups\nThe first thing we want to do is to separate the two survival curves. Do this by specifying a color aesthetic.\n\n\n\n\n\n\nHint\n\n\n\n\n\nThe variable you need to use is the one indicating the exposure group.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_step()\n\n\n\n\n\n\n\n\n\n\nThere are other methods for creating separate curves for separate groups, which you may want to look into at some other time.\n\n\n\n\n\nThicker lines\nA second thing we want to do is to make the lines thicker. Do this by setting the parameter linewidth in geom_step() to 2. (You can use some other value of your choice, something between 1.5 and 2 often works well depending on the use of the figure.)\n\n\n\n\n\n\nHint\n\n\n\n\n\nlinewidth should not be set as an aesthetic but as an ordinary parameter.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_step(linewidth = 2)\n\n\n\n\n\n\n\n\n\n\nThe case of many similar plots\n\n\n\nIf you are going to make many different plots, and for some reason you are not making a function to help out, it will be a good idea to have a global value you can use for linewidth (as you have bsize for base_size).\n\n\n\n\nConfidence interval bands\nWe now want to add confidence interval bands. To do this we use geom_stepribbon() from the pammtools package. Note that geom_stepribbon() requires 2 aesthetics we have not provided yet, ymin and ymax. Add geom_stepribbon() to the plot while specifying the additional aesthetics.\n\n\n\n\n\n\nHint 1\n\n\n\n\n\nymin and ymax can be added to the global aesthetics or locally within geom_stepribbon(aes()).\n\n\n\n\n\n\n\n\n\nHint 2\n\n\n\n\n\nThe variables you need to use for ymin and ymax are the ones determining the lower and upper confidence limits.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nFirst method: Inserting aesthetics locally within geom_stepribbon(). This is useful if these variables should be used here and other variables should be used for ymin and ymax elsewhere.\n\nggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_step(linewidth = 2) +\n  geom_stepribbon(aes(ymin = lcl, ymax = ucl))\n\nSecond method: Specifying aesthetics globally. This is useful if they should be used across several geom_s\n\nggplot(survival,\n       aes(x = time,\n           y = estimate, ymin = lcl, ymax = ucl,\n           color = x)\n       ) +\n  geom_step(linewidth = 2) +\n  geom_stepribbon()\n\nIn our example it makes no difference, as no other geom_s in this plot require ymin and ymax aesthetics.\n\n\n\n\n\nLayered graphics\nIf you added geom_stepribbon() as the last line in your plot, you will notice it covers (hides) the risk curves. We want the ribbons to be behind the curves, and we can achieve this by reversing the order of geom_step() and geom_stepribbon(). Do that.\n\n\n\n\n\n\nHint\n\n\n\n\n\nSimply switch the order of geom_step() and geom_stepribbon().\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_stepribbon(aes(ymin = lcl, ymax = ucl)) +\n  geom_step(linewidth = 2)\n\n\n\n\n\n\nRemove part of the legend\nNotice that the legend now has a dark background - geom_stepribbon() is also included in the legend. We don’t want that (well, you might - but for the sake of this exercise you don’t).\nWe can prevent geom_stepribbon() from transmitting to the legend by setting the parameter show.legend to FALSE within geom_stepribbon().\n\n\n\n\n\n\nHint (if you specified ymin and ymax as local aesthetics)\n\n\n\n\n\nParameters should be separated by commas, i.e., there must be a comma between aes() and show.legend.\n\n\n\n\n\n\n\n\n\nHint (regardless)\n\n\n\n\n\nshow.legend should be specified as an ordinary parameter not an aesthetic.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_stepribbon(aes(ymin = lcl, ymax = ucl),\n                  show.legend = FALSE) +\n  geom_step(linewidth = 2)\n\n\n\n\n\n\nColoring areas using fill\nWe also want the fill of the ribbons to be colored according to the exposure. We can achieve this by specifying the aesthetic fill - do that. (As for ymin and ymax, fill can be specified locally or globally, it should not make a difference in this exercise as fill is not used elsewhere.)\n\n\n\n\n\n\nHint\n\n\n\n\n\nThe variable used to determine the fill is the same as the one used for the color-aesthetic.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_stepribbon(aes(ymin = lcl, ymax = ucl, fill = x),\n                  show.legend = FALSE) +\n  geom_step(linewidth = 2)\n\n\n\n\n\n\nTransparency of areas using alpha\nWhoops, now we can’t see the actual curves. Better add some transparency to the ribbons. Do that by specifying the parameter alpha within geom_stepribbon(), e.g., set it to .2 (20% opacity / 80% transparency), or some other value of your preference.\n\n\n\n\n\n\nHint\n\n\n\n\n\nalpha should be specified as an ordinary parameter not an aesthetic. Remember to separate parameters by commas.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_stepribbon(aes(ymin = lcl, ymax = ucl, fill = x),\n                  show.legend = FALSE,\n                  alpha = .2) +\n  geom_step(linewidth = 2)\n\n\n\n\n\n\nEditing oulines of areas\nAgain, here comes a matter of taste. You might not want to have colored borders on you ribbons. You can remove them or, if you prefer, you might like to make them white. To remove the borders, specify the color-aesthetic locally (within aes() within geom_stepribbon()) to be NULL. To make the borders white, set the parameter (not the aesthetic) color to \"white\" within geom_stepribbon().\n\n\n\n\n\n\nSolution 1 - remove the borders\n\n\n\n\n\n\nggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_stepribbon(aes(ymin = lcl, ymax = ucl, fill = x, color = NULL),\n                  show.legend = FALSE,\n                  alpha = .2) +\n  geom_step(linewidth = 2)\n\n\n\n\n\n\n\n\n\n\nSolution 2 - white borders\n\n\n\n\n\n\nggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_stepribbon(aes(ymin = lcl, ymax = ucl, fill = x),\n                  show.legend = FALSE,\n                  alpha = .2,\n                  color = \"white\") +\n  geom_step(linewidth = 2)\n\n\n\n\n\n\nSpecifying colors\nThe default colors from ggplot2 are poor[citation needed]. We therefore want to use the values we specified initially as mypal. To do this we add 2 functions controlling the layout of the figure. Specifically, we will use scale_color_manual() and scale_fill_manual(), which both have a parameter called values. Set values to mypal.\n\n\n\n\n\n\nHint\n\n\n\n\n\nAdd scale_color_manual() and scale_fill_manual() in separate lines/at the end of the plot. Within each of these set values to mypal.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_stepribbon(aes(ymin = lcl, ymax = ucl, fill = x, color = NULL),\n                  show.legend = FALSE,\n                  alpha = .2) +\n  geom_step(linewidth = 2) +\n  scale_color_manual(values = mypal) +\n  scale_fill_manual(values = mypal)\n\n\n\n\n\n\nAdding % to tick labels\nAs a final step in making the base plot, i.e., the plot we will use to insert one plot into the other, we want to convert the y-axis to a percent-scale. We can do this using the function percent_format() from the scales package within the function scale_y_continuous() from ggplot2. Specifically, we need to specify that the parameter labels in scale_y_continuous() should be percent_format(accuracy = 1). Try playing with accuracy to see what it does (or check the documentation).\n\n\n\n\n\n\nHint\n\n\n\n\n\nFirst you need to add scale_y_continuous() as a separate line in the plot. Within scale_y_continuous() you need to specify the parameter labels as described above.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_stepribbon(aes(ymin = lcl, ymax = ucl, fill = x, color = NULL),\n                  show.legend = FALSE,\n                  alpha = .2) +\n  geom_step(linewidth = 2) +\n  scale_color_manual(values = mypal) +\n  scale_fill_manual(values = mypal) +\n  scale_y_continuous(labels = percent_format(accuracy = 1))\n\n\n\n\n\n\nCreating the object base\nThe last thing to do, is to make the plot into an object which you should name base (for internal consistency of this exercise - this name is not important in itself).\n\n\n\n\n\n\nHint\n\n\n\n\n\nSimply write base &lt;- in front of you plot and run it. An object called base should pop up in you Environment tab.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbase &lt;- ggplot(survival, aes(x = time, y = estimate, color = x)) +\n  geom_stepribbon(aes(ymin = lcl, ymax = ucl, fill = x, color = NULL),\n                  show.legend = FALSE,\n                  alpha = .2) +\n  geom_step(linewidth = 2) +\n  scale_color_manual(values = mypal) +\n  scale_fill_manual(values = mypal) +\n  scale_y_continuous(labels = percent_format(accuracy = 1))\n\n\n\n\n\n\nSo far so good..?\nAt this point you should have a plot looking somewhat like this (choice of color, widths of lines, outline and transparency of CI-bands, … may result in differences).\n\n\n\n\n\n\nShow plot",
    "crumbs": [
      "Plot in plot",
      "The base Kaplan-Meier plot"
    ]
  },
  {
    "objectID": "000_about.html",
    "href": "000_about.html",
    "title": "Risk curves in R",
    "section": "",
    "text": "About\nThis site is a brief walk-through of how various types of risk curves can be made in R. The focus is on the graphical rather than analytical aspects. I.e., we start from a dataset that has been analysed and cleaned and is ready to be plotted.\nSAS will be mentioned a few times but no knowledge of SAS is needed. However, it is assumed that the reader has some prior knowledge of ggplot2.\nThe data can be found here, scripts used to create this website are here.",
    "crumbs": [
      "Risk curves in R"
    ]
  },
  {
    "objectID": "011_load_pkg_and_data.html",
    "href": "011_load_pkg_and_data.html",
    "title": "Load packages and data",
    "section": "",
    "text": "Generic stuff\n\nLoad packages (install them first if aren’t already)\nThe packages ggplot2 and patchwork are essential for these plots. The other packages are used a bit here and there. The individual packages will be mentioned the first time they are used.\n\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(data.table)\nlibrary(dplyr)\nlibrary(pammtools)\nlibrary(scales)\n\n\n\nImport data\nWe load data with the function fread() (fast read) from the mighty data.table package. We do a bit of data management with functions from the very user-friendly (but less efficient) package dplyr.\nBelow, we set labels for the exposure variable, you may use different labels if you have other preferences.\nThe data set contains results for different analyses, presently we only need data for overall survival. We filter (restrict) to get the relevant data.\n\nsurvival &lt;- fread(\"//uni.au.dk/dfs/HE_KEA-DCESAS02/S/Stat day May 2025/risk_curves/data/riskdata.csv\") |&gt;\n  mutate(x = factor(\n    x,\n    levels = c(2,1),\n    labels = c(\"Control\", \"Intervention\")\n  )) |&gt;\n  filter(analysis == \"Survival\")\n\n\n\nGlobal values\nSet preferences for base size (this will affect sizes of axis titles and labels, legends, etc. but not the size of elements within the plot) and specify your 2 favorite colors for plotting curves. These preferences will be used in all plots.\nBase size:\n\nbsize &lt;- 15\n\nThere are many different named colors, e.g:\n\nmypal &lt;- c(\"navajowhite\", \"firebrick\")\n\nYou can use hex codes if you want to be specific about which colors to use:\n\nmypal &lt;- c(\"#aaaaaa\", \"#af0000\")\n\nWhenever we need to set the base size or specify colors in the following, we can use bsize and mypal. The upshot of specifying these values is that if we want to change the base size or the colors, we need to do so only once.\nAt a later point you might also look into global options.",
    "crumbs": [
      "Plot in plot",
      "Load packages and data"
    ]
  },
  {
    "objectID": "013_plot_in_plot.html",
    "href": "013_plot_in_plot.html",
    "title": "Plot within plot",
    "section": "",
    "text": "Inserting one plot into another\nHere we modify the base plot in 2 ways to get different versions of the same plot - inner and outer. We then insert one into the other.\nWe start by making the inner plot, we do this in 3 steps:\n\nA theme template for the inner plot\nFirst, we specify which built-in theme from ggplot2 we want to use as our template.\nMake a new plot by modifying base, i.e., add theme_minimal(base_size = bsize). The new plot should not overwrite base.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbase + \n  theme_minimal(base_size = bsize)\n\n\n\n\n\n\nRemoving the legend\nSecond, we want to remove the figure legend. We can edit the position of the legend by specifying legend.position to be \"none\" in a custom theme.\n\n\n\n\n\n\nHint\n\n\n\n\n\nYou can make a custom theme using the function theme. In this function you can specify legend.position.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbase +\n  theme_minimal(base_size = bsize) +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\nRemove axis titles\nThird, we want to remove titles on the x- and y-axes. To do this you need to set axis.title to element_blank() in your custom theme. Make this plot an object with the name inner.\n\n\n\n\n\n\nHint\n\n\n\n\n\nRemember to separate the specification of legend.position and axis.title by a comma.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ninner &lt;- base +\n  theme_minimal(base_size = bsize) +\n  theme(legend.position = \"none\",\n        axis.title = element_blank())\n\n\n\n\n\n\n\n\n\n\nBuilt-in and custom themes\n\n\n\nIf you specify your custom theme before a built-in theme, i.e., reverse their order, the built-in theme will overrule your customization.\n\n\nWe now turn to the outer plot.\n\n\nSetting the range of the y-axis for the outer plot\nAgain we start from base and we now make the y-axis go from 0 to 1 (the labels will be 0% to 100%).\nTo specify the range on the axes we use coord_cartesian(). In this you can specify ylim which should be a vector of length 2 with values 0 and 1.\n\n\n\n\n\n\nHint 1\n\n\n\n\n\nAdd coord_cartesian() to base, specify ylim within coord_cartesian().\n\n\n\n\n\n\n\n\n\nHint 2\n\n\n\n\n\nTo create a vector use the function c(). Write the values to be used in the vector separated by comma.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbase +\n  coord_cartesian(ylim = c(0, 1))\n\n\n\n\n\n\nSpecifying axis titles\nWe want the titles on the axes to be formatted better. We can do that with the function labs(). Within labs() specify parameters x and y with whatever titles you want to have on the x- and y-axes, e.g., Time and Survival.\n\n\n\n\n\n\nHint\n\n\n\n\n\nRemember quotation marks around the strings used to specify x and y.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbase +\n  coord_cartesian(ylim = c(0, 1)) +\n  labs(x = \"Time\", y = \"Survival\")\n\n\n\n\n\n\nAdding a theme template\nAs for the inner plot we want to use a built-in theme as a template and remove the legend. Use the built-in theme theme_classic() (specifying base_size) like you used theme_minimal() for the inner plot. Also, remove the legend like you did for the inner plot. Make the resulting plot an object called outer.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nouter &lt;- base +\n  coord_cartesian(ylim = c(0, 1)) +\n  labs(x = \"Time\", color = \"\", y = \"Survival\") +\n  theme_classic(base_size = bsize) +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\nInserting one plot into the other\nThe third and final step in inserting one plot into another is to use the function inset_element() from the patchwork package.\nStart with outer add the inset_element()-function with the first parameter set to inner. Also specify the parameters left, right, top and bottom as numeric values between 0 and 1, declaring where inner should be inserted inside outer.\nWhen you are happy with your choice of parameters make the result an object called pip.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npip &lt;- outer + inset_element(inner,\n                             left = .1,\n                             right = .97,\n                             top = .9,\n                             bottom = .05)\n\n\n\n\n\n\nThe resulting plot within plot\nYour current plot should something like this:\n\n\n\n\n\n\nShow plot",
    "crumbs": [
      "Plot in plot",
      "Plot within plot"
    ]
  },
  {
    "objectID": "015_patch.html",
    "href": "015_patch.html",
    "title": "Patch risk curves and -table",
    "section": "",
    "text": "Patching the curves and the risk table\nThe final step is done using patchwork once again. To put one plot-object (of ggplot-type) on top of another simply write them separated by a forward slash (/). Put pip on top of risktable\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npip / risktable\n\n\n\n\n\nSpecifying relative heights of plots\nThis does not look particularly good. We need the curves to make up most of the figure. We can set the relative heights between different rows using the function plot_layout(). Add plot_layout() with the parameter heights specified as a numerical vector with the same length as there are rows in the plot (in this case 2). The numerical values do not have to add up to 1 / 100%. If the values are x and 1 then the height of the first row will be x times the height of the second. When you are happy with the plot make it an object called pipatrisk.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npipatrisk &lt;- pip / risktable + plot_layout(heights = c(9,1))\n\n\n\n\n\n\nMove the y-axis title closer to the plot\nOne last thing, the title on the y-axis of the risk curves is a bit far away from the plot. We can move it to a better location. To do this we need to edit the first element (outer) of the first element (pip) of the final plot (pipatrisk - Figure 1).\n\n\n\n\n\n\n\n\nFigure 1: The components of plot pipatrisk\n\n\n\n\n\nSpecifically we need to add a custom theme in which axis.title.y is modified by element_text() in which vjust can be set to an appropriate number.\n\n\n\n\n\n\nHint\n\n\n\n\n\nYou can reference (and modify) the first element of the first element of the plot by expanding on this syntax:\n\npipatrisk[[1]][[1]] &lt;- pipatrisk[[1]][[1]] + ...\n\nAdd a custom theme to this.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# move label on y-axis closer to the figure\npipatrisk[[1]][[1]] &lt;- pipatrisk[[1]][[1]] +\n  theme(axis.title.y = element_text(vjust = -7))\n\n\n\n\n\n\nParty time!\nYour plot is now done, and you can save it using ggsave() or other devises.\n\n\n\n\n\n\nShow plot",
    "crumbs": [
      "Plot in plot",
      "Patch risk curves and -table"
    ]
  },
  {
    "objectID": "021_load_pkg_and_data.html",
    "href": "021_load_pkg_and_data.html",
    "title": "Load packages and data (again)",
    "section": "",
    "text": "The other part of the data set\nFor this exercise we use the risk part of the data, i.e., results from the Aalen-Johansen estimator (data on events of interest only, not competing events).\nConsider clearing your environment: rm(list = ls()).\nFor completeness all libraries are loaded again.\n\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(data.table)\nlibrary(dplyr)\nlibrary(pammtools)\nlibrary(scales)\n\n# subsetting to the risk analysis\nrisk &lt;- fread(\"//uni.au.dk/dfs/HE_KEA-DCESAS02/S/Stat day May 2025/risk_curves/data/riskdata.csv\") |&gt;\n  mutate(x = factor(\n    x,\n    levels = c(2,1),\n    labels = c(\"Control\", \"Intervention\")\n  )) |&gt;\n  filter(analysis != \"Survival\")\n\n# data for risk table\natrisk_risk &lt;- risk |&gt;\n  filter(is.na(natrisk) == F) |&gt;\n  select(x, time, natrisk, analysis)\n\nbsize &lt;- 15\n\nmypal &lt;- c(\"#aaaaaa\", \"#af0000\")",
    "crumbs": [
      "Plots in panels",
      "Load packages and data (again)"
    ]
  },
  {
    "objectID": "023_risk_table_function.html",
    "href": "023_risk_table_function.html",
    "title": "A ‘Risk table’ function",
    "section": "",
    "text": "Avoid repetitions - use functions (again)\nWe will now make a function that can produce risk tables for a each level of analysis, as we did for the risk curves.\nAgain, it is probably a good idea to make a risk table within one level of analysis and then wrap it up inside a function.\nAs for the risk curve function, you might want to\n\nstart by subsetting the data (atrisk_risk) to a level of analysis,\ndevelop a risk table as you did for the first exercise\n\nConsider if you want to have colors in this risk table - we have a legend inside the plot. Do what you find aesthetically most pleasing,\n\nwrap it up into a function (you can call it atrisk_fun).\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\natrisk_fun &lt;- function(thisanalysis){\n  temp &lt;- atrisk_risk |&gt;\n    filter(analysis == thisanalysis)\n  ggplot(temp, aes(x = time, y = x, label = natrisk)) +\n    geom_text(size = 4) +\n    theme_void(base_size = bsize) +\n    theme(axis.text.y = element_text(hjust = 1),\n          plot.title = element_text(hjust = -.1, size = bsize)) +\n    ggtitle(\"At risk\")\n}\n\n\n\n\n\n\n\n\n\n\nThe risk table for \"Cholera\"\n\n\n\n\n\n\natrisk_fun(\"Cholera\")",
    "crumbs": [
      "Plots in panels",
      "A 'Risk table' function"
    ]
  },
  {
    "objectID": "990_notes.html",
    "href": "990_notes.html",
    "title": "Notes",
    "section": "",
    "text": "Concepts beyond the scope of this day.",
    "crumbs": [
      "Notes"
    ]
  },
  {
    "objectID": "992_separating_lines.html",
    "href": "992_separating_lines.html",
    "title": "Separating lines",
    "section": "",
    "text": "Methods for separating lines for separate groups\nIf you do not want to use, or rely on colors when drawing curves for distinct groups, you can use other aesthetics. Specifying linetype = x instead of (Figure 1) or in combination with (Figure 2) color = x will apply different types of lines for different levels of x.\n\n\n\n\n\n\n\n\nFigure 1: linetype used without color or fill\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: linetype used in combination with color\n\n\n\n\n\nAnother possibility is to use the group-aesthetic as in Figure 3. In itself, this will make a separate line for each level of the exposure variable x with the same color and line type. I.e., there will be no distinguishing feature and no legend, which is not particularly useful in the current setup, though it can be useful in other settings.\n\n\n\n\n\n\n\n\nFigure 3: When using group there are no distinguishing features",
    "crumbs": [
      "Notes",
      "Separating lines"
    ]
  }
]